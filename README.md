# Задание 1. Анализ и планирование

### 1. Описание функциональности монолитного приложения

**Управление отоплением:**

- Пользователи могут устанавливать желаемую температуру воздуха в доме для системы отопления
- Пользователи могут переводить систему отопления в ждущий режим, для отключения нагрева воздуха в доме
- Система поддерживает:
  - добавление новых датчиков
  - обновление параметров датчиков
  - удаление датчиков
  - обновление статуса датчиков
- Недостатком является тот факт, что для добавления устройств необходим выезд специалиста

**Мониторинг температуры:**

- Пользователи могут получать информацию о температуре в доме
- Система поддерживает:
  - просмотр информации о температуре по всем датчикам
  - просмотр информации о температуре по конкретному датчику
  - просмотр информации о температуре по местоположению

### 2. Анализ архитектуры монолитного приложения

Система реализована по принципу монолитной архитектуры. Все функциональные компоненты приложения тесно связаны и развертываются как единое целое.
Ключевой характеристикой является синхронная, построенная по классической модели «запрос-ответ», блокирующая модель взаимодействия как между внутренними модулями приложения, так и с внешними устройствами (датчиками).

#### Ключевые компоненты системы

_Монолитное серверное приложение_ 
- Технологический стек: написано на языке Go (Golang), выбранном за свою производительность, простоту, эффективную работу с многопоточностью и встроенные возможности для разработки сетевых сервисов.
- Роль: Является центральным мозгом системы. Инкапсулирует в себе всю бизнес-логику, HTTP API, обработку данных и управление подключениями к базе данных.

_Слой данных_
- Хранилище: PostgreSQL — реляционная система управления базами данных, используемая для надежного и консистентного хранения всей информации.
- Хранимые данные: конфигурация датчиков, измеренная температура, метаданные (наименование, тип устройства, идентификаторы устройств и т.д.).

_Внешние устройства (датчики)_
- Роль: устройства, оснащенные температурными сенсорами. Выполняют роль подчиненных (slave) устройств в системе.
- Протокол взаимодействия: предположительно, HTTP/REST или простой TCP-протокол. Требует постоянной доступности и надежного сетевого соединения для работы.

### 3. Определение доменов и границы контекстов

#### Домен

_Умный дом_ - это общая предметная область, которая охватывает все аспекты управления и мониторинга температуры в доме.

#### Поддомены

В рамках этого домена можно выделить два ключевых поддомена:
- _Управление отоплением_ - управление и непосредственный контроль над системой отопления для поддержания комфортной температуры.
- _Мониторинг температуры_ - предоставляет информацию для принятия решений, но не управляет системой напрямую.

#### Ограниченные контексты

Система разделена на два ограниченных контекста, их границы проходят по функциональности и используемым данным.

| Контекст               | Ответственность                                                                  | Ключевые операции                                                                                                                               |
|------------------------|----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------|
| Управление отоплением  | Управление целевым состоянием системы отопления и конфигурацией ее оборудования. | - Установка целевой температуры.<br> - Включение/выключение системы (ждущий режим).<br> - Управление жизненным циклом датчиков (CRUD операции). |
| Мониторинг температуры | Предоставление актуальных данных о температуре для наблюдения.                   | - Чтение текущих показаний температуры.<br> - Запрос данных по датчикам и местоположениям.                                                      |

### **4. Проблемы монолитного решения**

- Монолит сложнее горизонтально масштабировать. Для увеличения производительности необходимо масштабировать все приложение целиком.
- Если датчик недоступен или отвечает с задержкой, это напрямую блокирует рабочие потоки сервера, потребляя его ресурсы впустую и потенциально создавая очередь из ожидающих запросов.
- Ошибка в любом небольшом модуле приложения может потенциально привести к падению всего сервиса.
- Синхронная модель может стать узким местом, так как время отклика системы на события ограничивается временем отклика самого медленного датчика в цепочке.

### 5. Визуализация контекста системы — диаграмма С4

[Диаграмма контекста](diagrams/monolith-context-diagram.puml)

# Задание 2. Проектирование микросервисной архитектуры

**Диаграмма контейнеров (Containers)**

[Диаграмма контейнеров системы](diagrams/system-containers-diagram.puml)

[Диаграмма контейнеров серверной части](diagrams/backend-containers-diagram.puml)

**Диаграмма компонентов (Components)**

Добавьте диаграмму для каждого из выделенных микросервисов.

**Диаграмма кода (Code)**

Добавьте одну диаграмму или несколько.

# Задание 3. Разработка ER-диаграммы

Добавьте сюда ER-диаграмму. Она должна отражать ключевые сущности системы, их атрибуты и тип связей между ними.

# Задание 4. Создание и документирование API

### 1. Тип API

Укажите, какой тип API вы будете использовать для взаимодействия микросервисов. Объясните своё решение.

### 2. Документация API

Здесь приложите ссылки на документацию API для микросервисов, которые вы спроектировали в первой части проектной работы. Для документирования используйте Swagger/OpenAPI или AsyncAPI.

# Задание 5. Работа с docker и docker-compose

Перейдите в apps.

Там находится приложение-монолит для работы с датчиками температуры. В README.md описано как запустить решение.

Вам нужно:

1) сделать простое приложение temperature-api на любом удобном для вас языке программирования, которое при запросе /temperature?location= будет отдавать рандомное значение температуры.

Locations - название комнаты, sensorId - идентификатор названия комнаты

```
	// If no location is provided, use a default based on sensor ID
	if location == "" {
		switch sensorID {
		case "1":
			location = "Living Room"
		case "2":
			location = "Bedroom"
		case "3":
			location = "Kitchen"
		default:
			location = "Unknown"
		}
	}

	// If no sensor ID is provided, generate one based on location
	if sensorID == "" {
		switch location {
		case "Living Room":
			sensorID = "1"
		case "Bedroom":
			sensorID = "2"
		case "Kitchen":
			sensorID = "3"
		default:
			sensorID = "0"
		}
	}
```

2) Приложение следует упаковать в Docker и добавить в docker-compose. Порт по умолчанию должен быть 8081

3) Кроме того для smart_home приложения требуется база данных - добавьте в docker-compose файл настройки для запуска postgres с указанием скрипта инициализации ./smart_home/init.sql

Для проверки можно использовать Postman коллекцию smarthome-api.postman_collection.json и вызвать:

- Create Sensor
- Get All Sensors

Должно при каждом вызове отображаться разное значение температуры

Ревьюер будет проверять точно так же.


